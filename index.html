<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Coding">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Coding">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Coding</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/2018-9-23-4-Promise-对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/2018-9-23-4-Promise-对象/" itemprop="url">2018-9-23-4 Promise 对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-24T00:06:32+08:00">
                2018-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-9-23-4-Promise-对象"><a href="#2018-9-23-4-Promise-对象" class="headerlink" title="2018-9-23-4 Promise 对象"></a>2018-9-23-4 Promise 对象</h1><h2 id="1-Promise的含义"><a href="#1-Promise的含义" class="headerlink" title="1. Promise的含义"></a>1. Promise的含义</h2><p>Promise 是异步编程的一种解决方法，比传统的解决方法–回掉函数和事件–更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存在某个未来才会执行的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。</p>
<p>创造了一个Promise实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(resolve, ms, &apos;done&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">timeout(100).then((value) =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">//&apos;done&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function() &#123;</span><br><span class="line">    console.log(&apos;resolve.&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;Hello&apos;);</span><br><span class="line"></span><br><span class="line">// promise</span><br><span class="line">// Hello</span><br><span class="line">// resolve.</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p>
<p>下面是异步加载图片的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loadImageAsync(url) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    const image = new Image();</span><br><span class="line"></span><br><span class="line">    image.onload = function() &#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = function() &#123;</span><br><span class="line">      reject(new Error(&apos;Could not load image at &apos; + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。</p>
<p>下面是一个用Promise对象实现的 Ajax 操作的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">  const promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    const handler = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const client = new XMLHttpRequest();</span><br><span class="line">    client.open(&quot;GET&quot;, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = &quot;json&quot;;</span><br><span class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  console.log(&apos;Contents: &apos; + json);</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  console.error(&apos;出错了&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;).then(r =&gt; &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  return resolve(1);</span><br><span class="line">  // 后面的语句不会执行</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/2018-9-23-3-Set和Map数据结构3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/2018-9-23-3-Set和Map数据结构3/" itemprop="url">2018-9-23-3 Set和Map数据结构3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-24T00:05:55+08:00">
                2018-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-9-23-3-Set和Map数据结构3"><a href="#2018-9-23-3-Set和Map数据结构3" class="headerlink" title="2018-9-23-3 Set和Map数据结构3"></a>2018-9-23-3 Set和Map数据结构3</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p>（1）Map 转为数组</p>
<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const myMap = new Map()</span><br><span class="line">  .set(true, 7)</span><br><span class="line">  .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">[...myMap]</span><br><span class="line">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ]</span><br></pre></td></tr></table></figure></p>
<p>（2）数组 转为 Map</p>
<p>将数组传入 Map 构造函数，就可以转为 Map。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&apos;abc&apos;]]</span><br><span class="line">])</span><br><span class="line">// Map &#123;</span><br><span class="line">//   true =&gt; 7,</span><br><span class="line">//   Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）Map 转为对象</p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj = Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myMap = new Map()</span><br><span class="line">  .set(&apos;yes&apos;, true)</span><br><span class="line">  .set(&apos;no&apos;, false);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p>（4）对象转为 Map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap = new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class="line">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span><br></pre></td></tr></table></figure></p>
<p>（5）Map 转为 JSON</p>
<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strMapToJson(strMap) &#123;</span><br><span class="line">  return JSON.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function mapToArrayJson(map) &#123;</span><br><span class="line">  return JSON.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;</span><br></pre></td></tr></table></figure></p>
<p>（6）JSON 转为 Map</p>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  return objToStrMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)</span><br><span class="line">// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function jsonToMap(jsonStr) &#123;</span><br><span class="line">  return new Map(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)</span><br><span class="line">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4.WeakMap"></a>4.WeakMap</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// WeakMap 可以使用 set 方法添加成员</span><br><span class="line">const wm1 = new WeakMap();</span><br><span class="line">const key = &#123;foo: 1&#125;;</span><br><span class="line">wm1.set(key, 2);</span><br><span class="line">wm1.get(key) // 2</span><br><span class="line"></span><br><span class="line">// WeakMap 也可以接受一个数组，</span><br><span class="line">// 作为构造函数的参数</span><br><span class="line">const k1 = [1, 2, 3];</span><br><span class="line">const k2 = [4, 5, 6];</span><br><span class="line">const wm2 = new WeakMap([[k1, &apos;foo&apos;], [k2, &apos;bar&apos;]]);</span><br><span class="line">wm2.get(k2) // &quot;bar&quot;</span><br></pre></td></tr></table></figure></p>
<p>WeakMap与Map的区别有两点。</p>
<p>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const map = new WeakMap();</span><br><span class="line">map.set(1, 2)</span><br><span class="line">// TypeError: 1 is not an object!</span><br><span class="line">map.set(Symbol(), 2)</span><br><span class="line">// TypeError: Invalid value used as weak map key</span><br><span class="line">map.set(null, 2)</span><br><span class="line">// TypeError: Invalid value used as weak map key</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果将数值1和Symbol值作为 WeakMap 的键名，都会报错。</p>
<p>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
<p>WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const wm = new WeakMap();</span><br><span class="line">let key = &#123;&#125;;</span><br><span class="line">let obj = &#123;foo: 1&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = null;</span><br><span class="line">wm.get(key)</span><br><span class="line">// Object &#123;foo: 1&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。</p>
<h4 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h4><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const wm = new WeakMap();</span><br><span class="line"></span><br><span class="line">// size、forEach、clear 方法都不存在</span><br><span class="line">wm.size // undefined</span><br><span class="line">wm.forEach // undefined</span><br><span class="line">wm.clear // undefined</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/2018-9-23-2-Set和Map数据结构2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/2018-9-23-2-Set和Map数据结构2/" itemprop="url">2018-9-23-2 Set和Map数据结构2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-24T00:05:32+08:00">
                2018-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-9-23-2-Set和Map数据结构2"><a href="#2018-9-23-2-Set和Map数据结构2" class="headerlink" title="2018-9-23-2 Set和Map数据结构2"></a>2018-9-23-2 Set和Map数据结构2</h1><h2 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <em>WeakSet 不可遍历</em>。</p>
<p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p>
<p>语法<br>WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ws = new WeakSet();</span><br></pre></td></tr></table></figure></p>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = [[1, 2], [3, 4]];</span><br><span class="line">const ws = new WeakSet(a);</span><br><span class="line">// WeakSet &#123;[1, 2], [3, 4]&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为 WeakSet 构造函数的参数，a的成员会自动成为 WeakSet 的成员。</p>
<p>注意，是a数组的成员成为 WeakSet 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const b = [3, 4];</span><br><span class="line">const ws = new WeakSet(b);</span><br><span class="line">// Uncaught TypeError: Invalid value used in weak set(</span><br></pre></td></tr></table></figure></p>
<p>WeakSet 结构有以下三个方法。</p>
<p>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。<br>下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">const w = new WeakSet();</span><br><span class="line">w.add(obj).add(global);</span><br><span class="line">console.log(w); </span><br><span class="line">console.log(w.has(global));</span><br><span class="line">console.log(w.delete(global));</span><br><span class="line">console.log(w.has(global));</span><br><span class="line">// WeakSet &#123;&#125;, 实际打印的效果</span><br><span class="line">// true</span><br><span class="line">// true</span><br><span class="line">// false</span><br></pre></td></tr></table></figure></p>
<p>WeakSet 没有size属性，没有办法遍历它的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(w.size);</span><br><span class="line">console.log(w.foreach);</span><br><span class="line">// undefined</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure></p>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。</p>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>含义和基本用法<br>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;&#125;;</span><br><span class="line">const element = document.getElementById(&apos;myDiv&apos;);</span><br><span class="line"></span><br><span class="line">data[element] = &apos;metadata&apos;;</span><br><span class="line">data[&apos;[object HTMLDivElement]&apos;] // &quot;metadata&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &quot;hello world&quot;&#125;;</span><br><span class="line">m.set(o, &quot;content&quot;);</span><br><span class="line">console.log(m.get(o));</span><br><span class="line">console.log(m.has(o));</span><br><span class="line">console.log(m.delete(o));</span><br><span class="line">// content</span><br><span class="line">// true</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map([[&quot;name&quot;, &quot;李四&quot;], [&quot;age&quot;, 20]]);</span><br><span class="line"></span><br><span class="line">console.log(m.size);</span><br><span class="line">console.log(m.has(&quot;name&quot;));</span><br><span class="line">console.log(m.get(&quot;name&quot;));</span><br><span class="line">console.log(m.get(&quot;age&quot;))</span><br><span class="line">console.log(m);</span><br><span class="line">// 2</span><br><span class="line">// true</span><br><span class="line">// 李四</span><br><span class="line">// 20</span><br><span class="line">// Map &#123; &apos;name&apos; =&gt; &apos;李四&apos;, &apos;age&apos; =&gt; 20 &#125;</span><br></pre></td></tr></table></figure></p>
<p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const items = [</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([[&quot;num&quot;, 6], [&quot;time&quot;, 2]]);</span><br><span class="line">const m1 = new Map(set);</span><br><span class="line">console.log(m1.get(&quot;num&quot;));//6</span><br><span class="line">const m2 = new Map([[1, &quot;hello&quot;]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">console.log(m2.get(1)); //&quot;hello&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<p>如果读取一个未知的键，则返回undefined。</p>
<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">console.log(map);//Map &#123; [ &apos;a&apos; ] =&gt; 555 &#125;</span><br><span class="line">console.log(map.get([&apos;a&apos;])) // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。  [‘a’]这种值的指向的地址都是不同的，因为它们是引用类型，虽然张的一样，但是它们的指向不同的地址，因为引擎要给他们分配不同的地址。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">const k1 = [&apos;a&apos;];</span><br><span class="line">const k2 = [&apos;a&apos;];</span><br><span class="line"></span><br><span class="line">m.set(k1, 111).set(k2, 222);</span><br><span class="line">console.log(m.get(k1));</span><br><span class="line">console.log(m.get(k2));</span><br><span class="line">// 111</span><br><span class="line">// 222</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br><span class="line"></span><br><span class="line">map.set(true, 1);</span><br><span class="line">map.set(&apos;true&apos;, 2);</span><br><span class="line">map.get(true) // 1</span><br><span class="line"></span><br><span class="line">map.set(undefined, 3);</span><br><span class="line">map.set(null, 4);</span><br><span class="line">map.get(undefined) // 3</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>
<p>此外，Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>forEach方法还可以接受第二个参数，用来绑定this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，forEach方法的回调函数的this，就指向reporter。</p>
<h3 id="实例的属性和操作方法。"><a href="#实例的属性和操作方法。" class="headerlink" title="实例的属性和操作方法。"></a>实例的属性和操作方法。</h3><p>1.size, 2.set(key, value), 3.get(key), 4.has(key), 5.delete(key), 6.clear()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">（1）size 属性</span><br><span class="line"></span><br><span class="line">size属性返回 Map 结构的成员总数。</span><br><span class="line"></span><br><span class="line">const map = new Map();</span><br><span class="line">map.set(&apos;foo&apos;, true);</span><br><span class="line">map.set(&apos;bar&apos;, false);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">（2）set(key, value)</span><br><span class="line"></span><br><span class="line">set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</span><br><span class="line"></span><br><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">m.set(&apos;edition&apos;, 6)        // 键是字符串</span><br><span class="line">m.set(262, &apos;standard&apos;)     // 键是数值</span><br><span class="line">m.set(undefined, &apos;nah&apos;)    // 键是 undefined</span><br><span class="line">set方法返回的是当前的Map对象，因此可以采用链式写法。</span><br><span class="line"></span><br><span class="line">let map = new Map()</span><br><span class="line">  .set(1, &apos;a&apos;)</span><br><span class="line">  .set(2, &apos;b&apos;)</span><br><span class="line">  .set(3, &apos;c&apos;);</span><br><span class="line">（3）get(key)</span><br><span class="line"></span><br><span class="line">get方法读取key对应的键值，如果找不到key，返回undefined。</span><br><span class="line"></span><br><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">const hello = function() &#123;console.log(&apos;hello&apos;);&#125;;</span><br><span class="line">m.set(hello, &apos;Hello ES6!&apos;) // 键是函数</span><br><span class="line"></span><br><span class="line">m.get(hello)  // Hello ES6!</span><br><span class="line">（4）has(key)</span><br><span class="line"></span><br><span class="line">has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</span><br><span class="line"></span><br><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">m.set(&apos;edition&apos;, 6);</span><br><span class="line">m.set(262, &apos;standard&apos;);</span><br><span class="line">m.set(undefined, &apos;nah&apos;);</span><br><span class="line"></span><br><span class="line">m.has(&apos;edition&apos;)     // true</span><br><span class="line">m.has(&apos;years&apos;)       // false</span><br><span class="line">m.has(262)           // true</span><br><span class="line">m.has(undefined)     // true</span><br><span class="line">（5）delete(key)</span><br><span class="line"></span><br><span class="line">delete方法删除某个键，返回true。如果删除失败，返回false。</span><br><span class="line"></span><br><span class="line">const m = new Map();</span><br><span class="line">m.set(undefined, &apos;nah&apos;);</span><br><span class="line">m.has(undefined)     // true</span><br><span class="line"></span><br><span class="line">m.delete(undefined)</span><br><span class="line">m.has(undefined)       // false</span><br><span class="line">（6）clear()</span><br><span class="line"></span><br><span class="line">clear方法清除所有成员，没有返回值。</span><br><span class="line"></span><br><span class="line">let map = new Map();</span><br><span class="line">map.set(&apos;foo&apos;, true);</span><br><span class="line">map.set(&apos;bar&apos;, false);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.clear()</span><br><span class="line">map.size // 0</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<p>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回所有成员的遍历器。<br>forEach()：遍历 Map 的所有成员。<br>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map([</span><br><span class="line">    [&quot;a&quot;, &quot;A&quot;],</span><br><span class="line">    [&quot;b&quot;, &quot;B&quot;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let i of m.keys()) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line"></span><br><span class="line">for (let v of m.values()) &#123;</span><br><span class="line">    console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// A</span><br><span class="line">// B</span><br><span class="line"></span><br><span class="line">for (let [key, value] of m.entries()) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">// a A</span><br><span class="line">// b B</span><br><span class="line"></span><br><span class="line">for (let item of m.entries()) &#123;</span><br><span class="line">    console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">// a A</span><br><span class="line">// b B</span><br><span class="line"></span><br><span class="line">//// 等同于使用m.entries()</span><br><span class="line">for (let [key, value] of m) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">// a A</span><br><span class="line">// b B</span><br></pre></td></tr></table></figure>
<p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[Symbol.iterator] === map.entries</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map([</span><br><span class="line">    [&quot;a&quot;, &quot;A&quot;],</span><br><span class="line">    [&quot;b&quot;, &quot;B&quot;],</span><br><span class="line">    [&quot;c&quot;, &quot;C&quot;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">console.log([...m.keys()]);</span><br><span class="line">console.log([...m.values()]);</span><br><span class="line">console.log([...m.entries()]);</span><br><span class="line">console.log([...m]);</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]</span><br><span class="line">// [ &apos;A&apos;, &apos;B&apos;, &apos;C&apos; ]</span><br><span class="line">// [ [ &apos;a&apos;, &apos;A&apos; ], [ &apos;b&apos;, &apos;B&apos; ], [ &apos;c&apos;, &apos;C&apos; ] ]</span><br><span class="line">// [ [ &apos;a&apos;, &apos;A&apos; ], [ &apos;b&apos;, &apos;B&apos; ], [ &apos;c&apos;, &apos;C&apos; ] ]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const map0 = new Map()</span><br><span class="line">  .set(1, &quot;a&quot;)</span><br><span class="line">  .set(2, &quot;b&quot;)</span><br><span class="line">  .set(3, &quot;c&quot;);</span><br><span class="line">console.log([...map0]); //[ [ 1, &apos;a&apos; ], [ 2, &apos;b&apos; ], [ 3, &apos;c&apos; ] ]</span><br><span class="line">const map1 = new Map(</span><br><span class="line">  [...map0].filter(([key, value]) =&gt; key &gt; 1)  </span><br><span class="line">);</span><br><span class="line">console.log(map1);</span><br><span class="line">// Map &#123; 2 =&gt; &apos;b&apos;, 3 =&gt; &apos;c&apos; &#125;</span><br><span class="line">const map2 = new Map(</span><br><span class="line">    [...map0].map(([key, value]) =&gt; [key*2, &apos;_&apos; + value ])</span><br><span class="line">)</span><br><span class="line">console.log(map2);</span><br><span class="line">//Map &#123; 2 =&gt; &apos;_a&apos;, 4 =&gt; &apos;_b&apos;, 6 =&gt; &apos;_c&apos; &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/2018-9-23-1-Set和Map数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/2018-9-23-1-Set和Map数据结构/" itemprop="url">2018-9-23-1 Set和Map数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-24T00:04:51+08:00">
                2018-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-9-23-1-Set和Map数据结构"><a href="#2018-9-23-1-Set和Map数据结构" class="headerlink" title="2018-9-23-1 Set和Map数据结构"></a>2018-9-23-1 Set和Map数据结构</h1><h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复值。</p>
<p>Set 本身是一个构造函数，用来生成Set数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line">[1, 2, 3, 4, 5, 4, 3, 2].forEach(x =&gt; s.add(x));</span><br><span class="line"></span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Set函数可以接受一个数组（或者具有iterable接口的其它数据结构）作为参数，用来初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">console.log(set);      //Set &#123; 1, 2, 3, 4 &#125;</span><br><span class="line">console.log([...set]); //[ 1, 2, 3, 4 ]</span><br></pre></td></tr></table></figure></p>
<p>上面形成了一种去除数组重复成员的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 3, 3, 3];</span><br><span class="line">console.log([...new Set(arr)]);</span><br><span class="line">//[ 1, 2, 3 ]</span><br></pre></td></tr></table></figure></p>
<p>在Set加入值的时候，不会发生类型转换，类似于精确相等运算符(===)，主要的区别是NaN等于自身，而精确相等运算NaN不等于自身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([NaN, NaN]);</span><br><span class="line">console.log(set);</span><br><span class="line">//Set &#123; NaN &#125;</span><br></pre></td></tr></table></figure></p>
<p>只能保存一个NaN，说明在Set内部，两个NaN相等。</p>
<p>两个对象总是不相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&#123;&#125;, &#123;&#125;]);</span><br><span class="line">console.log(set);</span><br><span class="line">//Set &#123; &#123;&#125;, &#123;&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set.prototype.constructor：构造函数，默认就是Set函数。<br>Set.prototype.size：返回Set实例的成员总数。</p>
<p>Set实例的方法分为两大类：操作方法（用于数据操作）和遍历方法（用于遍历成员）。下面介绍四个操作方法。</p>
<ul>
<li>add(value): 添加某个值返回Set结构本身。</li>
<li>delete(value): 删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value): 返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear(): 清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let s = new Set();</span><br><span class="line">s.add(1).add(2).add(3).add(3);</span><br><span class="line">console.log(s);//Set &#123;1, 2, 3&#125;</span><br><span class="line">console.log(s.delete(2));//true</span><br><span class="line">console.log(s.has(2));//false</span><br><span class="line">console.log(s.clear());//undefined</span><br><span class="line">console.log(s);//Set &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对比，判断包括在一个键上面，Object结构和Set结构的写法不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//对象的写法</span><br><span class="line">const o = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">if (o[&apos;a&apos;])&#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br><span class="line">//Set的写法</span><br><span class="line">const s = new Set();</span><br><span class="line">s.add(&apos;a&apos;).add(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">if (s.has(&apos;a&apos;)) &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Array.from方法可以将Set结构转化为数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">const arr = Array.from(set);</span><br><span class="line">console.log(arr);</span><br><span class="line">//[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure></p>
<h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><p>keys()：返回键名的遍历器<br>values()：返回键值的遍历器<br>entries()：返回键值对的遍历器<br>forEach()：使用回调函数遍历每个成员</p>
<p><em>需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</em></p>
<h4 id="（1）keys-，values-，entries"><a href="#（1）keys-，values-，entries" class="headerlink" title="（1）keys()，values()，entries()"></a>（1）keys()，values()，entries()</h4><p>keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);</span><br><span class="line">for (let i of set.keys()) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let i of set.values()) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let i of set.entries()) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// [ &apos;red&apos;, &apos;red&apos; ]</span><br><span class="line">// [ &apos;green&apos;, &apos;green&apos; ]</span><br><span class="line">// [ &apos;blue&apos;, &apos;blue&apos; ]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。<br>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype[Symbol.iterator] === Set.prototype.values</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>这意味着，可以省略values方法，直接用for…of循环遍历 Set。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line"></span><br><span class="line">for (let x of set) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure></p>
<h5 id="（2）forEach"><a href="#（2）forEach" class="headerlink" title="（2）forEach()"></a>（2）forEach()</h5><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);</span><br><span class="line">set.forEach((key, value) =&gt; console.log(key + &quot; : &quot; + value));</span><br><span class="line">// red : red</span><br><span class="line">// green : green</span><br><span class="line">// blue : blue</span><br></pre></td></tr></table></figure></p>
<p>forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。<br>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [3, 5, 2, 2, 5, 5];</span><br><span class="line">let unique = [...new Set(arr)];</span><br><span class="line">// [3, 5, 2]</span><br></pre></td></tr></table></figure></p>
<p>而且，数组的map和filter方法也可以间接用于 Set 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3]);</span><br><span class="line">set = new Set([...set].map(x =&gt; x * 2));</span><br><span class="line">// 返回Set结构：&#123;2, 4, 6&#125;</span><br><span class="line"></span><br><span class="line">let set = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">set = new Set([...set].filter(x =&gt; (x % 2) == 0));</span><br><span class="line">// 返回Set结构：&#123;2, 4&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3]);</span><br><span class="line">let b = new Set([2, 3, 4]);</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">console.log(new Set([...a, ...b]));</span><br><span class="line">//Set &#123; 1, 2, 3, 4 &#125;</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">console.log(new Set([...a].filter(x =&gt; b.has(x))));</span><br><span class="line">// Set &#123; 2, 3 &#125;</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">console.log(new Set([...a].filter(x =&gt; !b.has(x))));</span><br><span class="line">// Set &#123; 1 &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3]);</span><br><span class="line">set = new Set([...set].map(val =&gt; val * 2));</span><br><span class="line">console.log(set);</span><br><span class="line">// Set &#123;2, 3, 6&#125;</span><br><span class="line"></span><br><span class="line">set = new Set(Array.from(set, val =&gt; val * 2));</span><br><span class="line">console.log(set);</span><br><span class="line">// Set &#123; 4, 8, 12 &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/23/2018-9-23-箭头函数中的一段代码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/2018-9-23-箭头函数中的一段代码分析/" itemprop="url">2018-9-23 箭头函数中的一段代码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-23T15:28:33+08:00">
                2018-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer = new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);</span><br><span class="line">setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);</span><br></pre></td></tr></table></figure>
<p>分析<br><code>var timer = new Timer();</code><br>分析 new 之后发生了什么。<br>1.首先创建一个新的空对象。<br>{}<br>2.接下来，new设置this，使其指向这个新对象timer。</p>
<p>3.设置this后，调用Timer()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.接下来这行这个函数的代码。Timer() 给新创建的属性赋值。<br>这个过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前两项完成属性赋值。</span><br><span class="line">&#123;</span><br><span class="line">  s1: 0;//会随时间的变化执行++；</span><br><span class="line">  s2: 0;//不变。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(() =&gt; this.s1++, 1000);</span><br></pre></td></tr></table></figure>
<p>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>这个this指向我们定义的这个对象，我们定义的对象有执行代码这一步,每过1秒增加s1 = s1 + 1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br></pre></td></tr></table></figure></p>
<p>上面的function()是一个匿名函数。<br>匿名函数的执行环境具有全局性。<br>也同样执行，但是其this指向的是window。所以其效果是在window.this++，为undefined++结果是NaN，这个值和上面的timer对象中的s2不产生关系。</p>
<p>5.Timer()函数执行完毕，运算符返回this，指向新创建的对象的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);</span><br></pre></td></tr></table></figure>
<p>上面的代码就是对timer.s1++每隔1秒执行次，在第3.1秒的时候打印出结果。floor(3.1/1)==3,经过三次加1，得到结果timer.s1 = 3;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是打印出timer.s2，由于setInterval()函数没有对timer.s2的s2这个属性值操作（它针对window.s2进行了操作），所以打印出结果为初始化的值0。</p>
<p>如果想让tiemr.s2属性也能递增，可以通过下面的操作实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  that = this;</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    that.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer = new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100); </span><br><span class="line">setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);</span><br><span class="line">// s1:  3</span><br><span class="line">// s2:  3</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/23/2018-9-22-5-数组的拓展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/2018-9-22-5-数组的拓展/" itemprop="url">2018-9-22-5 数组的拓展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-23T11:46:09+08:00">
                2018-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-9-22-5-数组的拓展。"><a href="#2018-9-22-5-数组的拓展。" class="headerlink" title="2018-9-22-5 数组的拓展。"></a>2018-9-22-5 数组的拓展。</h1><h2 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1.扩展运算符"></a>1.扩展运算符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(&apos;div&apos;)]</span><br><span class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure></p>
<p>该运算符主要用于函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">const args = [0, 1];</span><br><span class="line">f(-1, ...args, 2, ...[3]);</span><br></pre></td></tr></table></figure></p>
<p>扩展运算符后面还可以放置表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr = [</span><br><span class="line">  ...(x &gt; 0 ? [&apos;a&apos;] : []),</span><br><span class="line">  &apos;b&apos;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如果扩展运算符后面是一个空数组，则不产生任何效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[], 1]</span><br><span class="line">// [1]</span><br></pre></td></tr></table></figure></p>
<h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h3><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">let args = [0, 1, 2];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure></p>
<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5的 写法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">let arr1 = [0, 1, 2];</span><br><span class="line">let arr2 = [3, 4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></p>
<p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">new (Date.bind.apply(Date, [null, 2015, 1, 1]))</span><br><span class="line">// ES6</span><br><span class="line">new Date(...[2015, 1, 1]);</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p>（1）复制数组</p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[0] = 2;</span><br><span class="line">a1 // [2, 2]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。</p>
<p>ES5 只能用变通方法来复制数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] = 2;</span><br><span class="line">a1 // [1, 2]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">// 写法一</span><br><span class="line">const a2 = [...a1];</span><br><span class="line">// 写法二</span><br><span class="line">const [...a2] = a1;</span><br></pre></td></tr></table></figure></p>
<p>上面的两种写法，a2都是a1的克隆。</p>
<p>（2）合并数组</p>
<p>扩展运算符提供了数组合并的新写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">const arr2 = [&apos;c&apos;];</span><br><span class="line">const arr3 = [&apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// ES5 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br><span class="line"></span><br><span class="line">// ES6 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br></pre></td></tr></table></figure></p>
<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [&#123; foo: 1 &#125;];</span><br><span class="line">const a2 = [&#123; bar: 2 &#125;];</span><br><span class="line"></span><br><span class="line">const a3 = a1.concat(a2);</span><br><span class="line">const a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[0] === a1[0] // true</span><br><span class="line">a4[0] === a1[0] // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。</p>
<p>（3）与解构赋值结合</p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">a = list[0], rest = list.slice(1)</span><br><span class="line">// ES6</span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure></p>
<p>下面是另外一些例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [];</span><br><span class="line">first // undefined</span><br><span class="line">rest  // []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [&quot;foo&quot;];</span><br><span class="line">first  // &quot;foo&quot;</span><br><span class="line">rest   // []</span><br></pre></td></tr></table></figure></p>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure></p>
<p>（4）字符串</p>
<p>扩展运算符还可以将字符串转为真正的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...&apos;hello&apos;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;x\uD83D\uDE80y&apos;.length // 4</span><br><span class="line">[...&apos;x\uD83D\uDE80y&apos;].length // 3</span><br></pre></td></tr></table></figure></p>
<p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function length(str) &#123;</span><br><span class="line">  return [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(&apos;x\uD83D\uDE80y&apos;) // 3</span><br></pre></td></tr></table></figure></p>
<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;x\uD83D\uDE80y&apos;;</span><br><span class="line"></span><br><span class="line">str.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">// &apos;y\uDE80\uD83Dx&apos;</span><br><span class="line"></span><br><span class="line">[...str].reverse().join(&apos;&apos;)</span><br><span class="line">// &apos;y\uD83D\uDE80x&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<p>（5）实现了 Iterator 接口的对象</p>
<p>任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let nodeList = document.querySelectorAll(&apos;div&apos;);</span><br><span class="line">let array = [...nodeList];</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">  &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">  &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">  &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// TypeError: Cannot spread non-iterable object.</span><br><span class="line">let arr = [...arrayLike];</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<p>（6）Map 和 Set 结构，Generator 函数</p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">  [1, &apos;one&apos;],</span><br><span class="line">  [2, &apos;two&apos;],</span><br><span class="line">  [3, &apos;three&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr = [...map.keys()]; // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const go = function*()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let arr = [...obj]; // TypeError: Cannot spread non-iterable object</span><br></pre></td></tr></table></figure></p>
<h2 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.Array.from()"></a>2.Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>下面是一个类似数组的对象，Array.from将它转为真正的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// NodeList对象</span><br><span class="line">let ps = document.querySelectorAll(&apos;p&apos;);</span><br><span class="line">Array.from(ps).filter(p =&gt; &#123;</span><br><span class="line">  return p.textContent.length &gt; 100;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var args = Array.from(arguments);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。</p>
<p>只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&apos;hello&apos;)</span><br><span class="line">// [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]</span><br><span class="line"></span><br><span class="line">let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])</span><br><span class="line">Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。</p>
<p>如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, 2, 3])</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arguments对象</span><br><span class="line">function foo() &#123;</span><br><span class="line">  const args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NodeList对象</span><br><span class="line">[...document.querySelectorAll(&apos;div&apos;)]</span><br></pre></td></tr></table></figure></p>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 3 &#125;);</span><br><span class="line">// [ undefined, undefined, undefined ]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。</p>
<p>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const toArray = (() =&gt;</span><br><span class="line">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure></p>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</span><br><span class="line">// [1, 4, 9]</span><br></pre></td></tr></table></figure></p>
<p>下面的例子是取出一组 DOM 节点的文本内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let spans = document.querySelectorAll(&apos;span.name&apos;);</span><br><span class="line"></span><br><span class="line">// map()</span><br><span class="line">let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);</span><br><span class="line"></span><br><span class="line">// Array.from()</span><br><span class="line">let names2 = Array.from(spans, s =&gt; s.textContent)</span><br></pre></td></tr></table></figure></p>
<p>下面的例子将数组中布尔值为false的成员转为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, , 2, , 3], (n) =&gt; n || 0)</span><br><span class="line">// [1, 0, 2, 0, 3]</span><br></pre></td></tr></table></figure></p>
<p>另一个例子是返回各种数据的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function typesOf () &#123;</span><br><span class="line">  return Array.from(arguments, value =&gt; typeof value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(null, [], NaN)</span><br><span class="line">// [&apos;object&apos;, &apos;object&apos;, &apos;number&apos;]</span><br></pre></td></tr></table></figure></p>
<p>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</p>
<p>Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 2 &#125;, () =&gt; &apos;jack&apos;)</span><br><span class="line">// [&apos;jack&apos;, &apos;jack&apos;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>
<p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function countSymbols(string) &#123;</span><br><span class="line">  return Array.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3.Array.of()"></a>3.Array.of()</h2><p>Array.of方法用于将一组值，转换为数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br></pre></td></tr></table></figure></p>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.of() // []</span><br><span class="line">Array.of(undefined) // [undefined]</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br></pre></td></tr></table></figure></p>
<p>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p>Array.of方法可以用下面的代码模拟实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ArrayOf()&#123;</span><br><span class="line">  return [].slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4.数组实例的 copyWithin()"></a>4.数组实例的 copyWithin()</h2><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.copyWithin(target, start = 0, end = this.length)</span><br></pre></td></tr></table></figure></p>
<p>它接受三个参数。</p>
<p>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。<br>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</span><br><span class="line">// [4, 5, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>
<p>下面是更多例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 将3号位复制到0号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4)</span><br><span class="line">// [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// -2相当于3号位，-1相当于4号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, -2, -1)</span><br><span class="line">// [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// 将3号位复制到0号位</span><br><span class="line">[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)</span><br><span class="line">// &#123;0: 1, 3: 1, length: 5&#125;</span><br><span class="line"></span><br><span class="line">// 将2号位到数组结束，复制到0号位</span><br><span class="line">let i32a = new Int32Array([1, 2, 3, 4, 5]);</span><br><span class="line">i32a.copyWithin(0, 2);</span><br><span class="line">// Int32Array [3, 4, 5, 4, 5]</span><br><span class="line"></span><br><span class="line">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span><br><span class="line">// 需要采用下面的写法</span><br><span class="line">[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);</span><br><span class="line">// Int32Array [4, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>
<h3 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find() 和 findIndex()"></a>数组实例的 find() 和 findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line">上面代码找出数组中第一个小于 0 的成员。</span><br><span class="line"></span><br><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure></p>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(v)&#123;</span><br><span class="line">  return v &gt; this.age;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;name: &apos;John&apos;, age: 20&#125;;</span><br><span class="line">[10, 12, 26, 15].find(f, person);    // 26</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。</p>
<p>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br><span class="line"></span><br><span class="line">[NaN].findIndex(y =&gt; Object.is(NaN, y))</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<p>6.数组实例的 fill()<br>fill方法使用给定值，填充一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure></p>
<p>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</span><br><span class="line">// [&apos;a&apos;, 7, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);</span><br><span class="line">arr[0].name = &quot;Ben&quot;;</span><br><span class="line">arr</span><br><span class="line">// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span><br><span class="line"></span><br><span class="line">let arr = new Array(3).fill([]);</span><br><span class="line">arr[0].push(5);</span><br><span class="line">arr</span><br><span class="line">// [[5], [5], [5]]</span><br></pre></td></tr></table></figure></p>
<h3 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7.数组实例的 entries()，keys() 和 values()"></a>7.数组实例的 entries()，keys() 和 values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">let entries = letter.entries();</span><br><span class="line">console.log(entries.next().value); // [0, &apos;a&apos;]</span><br><span class="line">console.log(entries.next().value); // [1, &apos;b&apos;]</span><br><span class="line">console.log(entries.next().value); // [2, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<h3 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8.数组实例的 includes()"></a>8.数组实例的 includes()</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // true</span><br><span class="line">[1, 2, 3].includes(4)     // false</span><br><span class="line">[1, 2, NaN].includes(NaN) // true</span><br></pre></td></tr></table></figure></p>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3);  // false</span><br><span class="line">[1, 2, 3].includes(3, -1); // true</span><br></pre></td></tr></table></figure></p>
<p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (arr.indexOf(el) !== -1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br></pre></td></tr></table></figure></p>
<p>includes使用的是不一样的判断算法，就没有这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NaN].includes(NaN)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const contains = (() =&gt;</span><br><span class="line">  Array.prototype.includes</span><br><span class="line">    ? (arr, value) =&gt; arr.includes(value)</span><br><span class="line">    : (arr, value) =&gt; arr.some(el =&gt; el === value)</span><br><span class="line">)();</span><br><span class="line">contains([&apos;foo&apos;, &apos;bar&apos;], &apos;baz&apos;); // =&gt; false</span><br></pre></td></tr></table></figure></p>
<p>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。</p>
<p>Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。<br>Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</p>
<h3 id="9-数组的空位"><a href="#9-数组的空位" class="headerlink" title="9.数组的空位"></a>9.数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(3) // [, , ,]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Array(3)返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 in [undefined, undefined, undefined] // true</span><br><span class="line">0 in [, , ,] // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<p>forEach(), filter(), reduce(), every() 和some()都会跳过空位。<br>map()会跳过空位，但会保留这个值<br>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// forEach方法</span><br><span class="line">[,&apos;a&apos;].forEach((x,i) =&gt; console.log(i)); // 1</span><br><span class="line"></span><br><span class="line">// filter方法</span><br><span class="line">[&apos;a&apos;,,&apos;b&apos;].filter(x =&gt; true) // [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line"></span><br><span class="line">// every方法</span><br><span class="line">[,&apos;a&apos;].every(x =&gt; x===&apos;a&apos;) // true</span><br><span class="line"></span><br><span class="line">// reduce方法</span><br><span class="line">[1,,2].reduce((x,y) =&gt; x+y) // 3</span><br><span class="line"></span><br><span class="line">// some方法</span><br><span class="line">[,&apos;a&apos;].some(x =&gt; x !== &apos;a&apos;) // false</span><br><span class="line"></span><br><span class="line">// map方法</span><br><span class="line">[,&apos;a&apos;].map(x =&gt; 1) // [,1]</span><br><span class="line"></span><br><span class="line">// join方法</span><br><span class="line">[,&apos;a&apos;,undefined,null].join(&apos;#&apos;) // &quot;#a##&quot;</span><br><span class="line"></span><br><span class="line">// toString方法</span><br><span class="line">[,&apos;a&apos;,undefined,null].toString() // &quot;,a,,&quot;</span><br></pre></td></tr></table></figure></p>
<p>ES6 则是明确将空位转为undefined。</p>
<p>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([&apos;a&apos;,,&apos;b&apos;])</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>扩展运算符（…）也会将空位转为undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[&apos;a&apos;,,&apos;b&apos;]]</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>copyWithin()会连空位一起拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<p>fill()会将空位视为正常的数组位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(3).fill(&apos;a&apos;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<p>for…of循环也会遍历空位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [, ,];</span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</span><br><span class="line"></span><br><span class="line">// entries()</span><br><span class="line">[...[,&apos;a&apos;].entries()] // [[0,undefined], [1,&quot;a&quot;]]</span><br><span class="line"></span><br><span class="line">// keys()</span><br><span class="line">[...[,&apos;a&apos;].keys()] // [0,1]</span><br><span class="line"></span><br><span class="line">// values()</span><br><span class="line">[...[,&apos;a&apos;].values()] // [undefined,&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">// find()</span><br><span class="line">[,&apos;a&apos;].find(x =&gt; true) // undefined</span><br><span class="line"></span><br><span class="line">// findIndex()</span><br><span class="line">[,&apos;a&apos;].findIndex(x =&gt; true) // 0</span><br></pre></td></tr></table></figure></p>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/23/2018-9-22-4-函数的扩展-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/2018-9-22-4-函数的扩展-2/" itemprop="url">2018-9-22-3 函数的扩展 2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-23T11:44:51+08:00">
                2018-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-9-22-4-函数的扩展-2"><a href="#2018-9-22-4-函数的扩展-2" class="headerlink" title="2018-9-22-4 函数的扩展 2"></a>2018-9-22-4 函数的扩展 2</h1><h2 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5.箭头函数"></a>5.箭头函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许使用“箭头”（=&gt;）定义函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;</span><br></pre></td></tr></table></figure></p>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// 不报错</span><br><span class="line">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br><span class="line">下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</span><br><span class="line"></span><br><span class="line">let foo = () =&gt; &#123; a: 1 &#125;;</span><br><span class="line">foo() // undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。</p>
<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fn = () =&gt; void doesNotReturn();</span><br></pre></td></tr></table></figure></p>
<p>箭头函数可以与变量解构结合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const full = (&#123; first, last &#125;) =&gt; first + &apos; &apos; + last;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function full(person) &#123;</span><br><span class="line">  return person.first + &apos; &apos; + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数使得表达更加简洁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const isEven = n =&gt; n % 2 == 0;</span><br><span class="line">const square = n =&gt; n * n;</span><br></pre></td></tr></table></figure></p>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数写法</span><br><span class="line">[1,2,3].map(function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure></p>
<p>另一个例子是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数写法</span><br><span class="line">var result = values.sort(function (a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">var result = values.sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure></p>
<p>下面是 rest 参数与箭头函数结合的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const numbers = (...nums) =&gt; nums;</span><br><span class="line"></span><br><span class="line">numbers(1, 2, 3, 4, 5)</span><br><span class="line">// [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">const headAndTail = (head, ...tail) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(1, 2, 3, 4, 5)</span><br><span class="line">// [1,[2,3,4,5]]</span><br></pre></td></tr></table></figure></p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer = new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);</span><br><span class="line">setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);</span><br><span class="line">// s1: 3</span><br><span class="line">// s2: 0</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。</p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  id: &apos;123456&apos;,</span><br><span class="line"></span><br><span class="line">  init: function() &#123;</span><br><span class="line">    document.addEventListener(&apos;click&apos;,</span><br><span class="line">      event =&gt; this.doSomething(event.type), false);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: function(type) &#123;</span><br><span class="line">    console.log(&apos;Handling &apos; + type  + &apos; for &apos; + this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var _this = this;</span><br><span class="line"></span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, _this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<p>请问下面的代码之中有几个this？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        console.log(&apos;id:&apos;, this.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = foo.call(&#123;id: 1&#125;);</span><br><span class="line"></span><br><span class="line">var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1</span><br><span class="line">var t2 = f().call(&#123;id: 3&#125;)(); // id: 1</span><br><span class="line">var t3 = f()().call(&#123;id: 4&#125;); // id: 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。</p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;args:&apos;, arguments);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(2, 4, 6, 8)</span><br><span class="line">// args: [2, 4, 6, 8]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  return [</span><br><span class="line">    (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)()</span><br><span class="line">  ];</span><br><span class="line">&#125;).call(&#123; x: &apos;outer&apos; &#125;);</span><br><span class="line">// [&apos;outer&apos;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。</p>
<p>长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p>
<h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function insert(value) &#123;</span><br><span class="line">  return &#123;into: function (array) &#123;</span><br><span class="line">    return &#123;after: function (afterValue) &#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + 1, 0, value);</span><br><span class="line">      return array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>上面这个函数，可以使用箭头函数改写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + 1, 0, value);</span><br><span class="line">  return array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pipeline = (...funcs) =&gt;</span><br><span class="line">  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);</span><br><span class="line"></span><br><span class="line">const plus1 = a =&gt; a + 1;</span><br><span class="line">const mult2 = a =&gt; a * 2;</span><br><span class="line">const addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(5)</span><br><span class="line">// 12</span><br></pre></td></tr></table></figure></p>
<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const plus1 = a =&gt; a + 1;</span><br><span class="line">const mult2 = a =&gt; a * 2;</span><br><span class="line"></span><br><span class="line">mult2(plus1(5))</span><br><span class="line">// 12</span><br><span class="line">箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</span><br><span class="line"></span><br><span class="line">// λ演算的写法</span><br><span class="line">fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))</span><br><span class="line">               (x =&gt; f(v =&gt; x(x)(v)));</span><br></pre></td></tr></table></figure></p>
<p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>
<h3 id="6-双冒号运算符-在node和chrome中测试都不行，可能还没有被应用"><a href="#6-双冒号运算符-在node和chrome中测试都不行，可能还没有被应用" class="headerlink" title="6.双冒号运算符 (在node和chrome中测试都不行，可能还没有被应用)"></a>6.双冒号运算符 (在node和chrome中测试都不行，可能还没有被应用)</h3><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p>
<p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line">// 等同于</span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line">// 等同于</span><br><span class="line">bar.apply(foo, arguments);</span><br><span class="line"></span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line">function hasOwn(obj, key) &#123;</span><br><span class="line">  return obj::hasOwnProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var method = obj::obj.foo;</span><br><span class="line">// 等同于</span><br><span class="line">var method = ::obj.foo;</span><br><span class="line"></span><br><span class="line">let log = ::console.log;</span><br><span class="line">// 等同于</span><br><span class="line">var log = console.log.bind(console);</span><br></pre></td></tr></table></figure></p>
<p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;</span><br><span class="line"></span><br><span class="line">getPlayers()</span><br><span class="line">::map(x =&gt; x.character())</span><br><span class="line">::takeWhile(x =&gt; x.strength &gt; 100)</span><br><span class="line">::forEach(x =&gt; console.log(x));</span><br></pre></td></tr></table></figure></p>
<h3 id="7-尾调用优化"><a href="#7-尾调用优化" class="headerlink" title="7.尾调用优化"></a>7.尾调用优化</h3><p>什么是尾调用？<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p>
<p>以下三种情况，都不属于尾调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  return undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(x) &#123;</span><br><span class="line">  if (x &gt; 0) &#123;</span><br><span class="line">    return m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  return n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  let m = 1;</span><br><span class="line">  let n = 2;</span><br><span class="line">  return g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function f() &#123;</span><br><span class="line">  return g(3);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">g(3);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addOne(a)&#123;</span><br><span class="line">  var one = 1;</span><br><span class="line">  function inner(b)&#123;</span><br><span class="line">    return b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  return inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n) &#123;</span><br><span class="line">  if (n === 1) return 1;</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure></p>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure></p>
<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Fibonacci (n) &#123;</span><br><span class="line">  if ( n &lt;= 1 ) &#123;return 1&#125;;</span><br><span class="line"></span><br><span class="line">  return Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(10) // 89</span><br><span class="line">Fibonacci(100) // 堆栈溢出</span><br><span class="line">Fibonacci(500) // 堆栈溢出</span><br></pre></td></tr></table></figure></p>
<p>尾递归优化过的 Fibonacci 数列实现如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</span><br><span class="line">  if( n &lt;= 1 ) &#123;return ac2&#125;;</span><br><span class="line"></span><br><span class="line">  return Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci2(100) // 573147844013817200000</span><br><span class="line">Fibonacci2(1000) // 7.0330367711422765e+208</span><br><span class="line">Fibonacci2(10000) // Infinity</span><br></pre></td></tr></table></figure></p>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">  return tailFactorial(n, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure></p>
<p>上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn, n) &#123;</span><br><span class="line">  return function (m) &#123;</span><br><span class="line">    return fn.call(this, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tailFactorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const factorial = currying(tailFactorial, 1);</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure></p>
<p>上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。</p>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total = 1) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<p>严格模式<br>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<p>func.arguments：返回调用时函数的参数。<br>func.caller：返回调用当前函数的那个函数。<br>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function restricted() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  restricted.caller;    // 报错</span><br><span class="line">  restricted.arguments; // 报错</span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure></p>
<p>尾递归优化的实现<br>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sum(x, y) &#123;</span><br><span class="line">  if (y &gt; 0) &#123;</span><br><span class="line">    return sum(x + 1, y - 1);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 100000)</span><br><span class="line">// Uncaught RangeError: Maximum call stack size exceeded(…)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function trampoline(f) &#123;</span><br><span class="line">  while (f &amp;&amp; f instanceof Function) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(x, y) &#123;</span><br><span class="line">  if (y &gt; 0) &#123;</span><br><span class="line">    return sum.bind(null, x + 1, y - 1);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，sum函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trampoline(sum(1, 100000))</span><br><span class="line">// 100001</span><br></pre></td></tr></table></figure></p>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function tco(f) &#123;</span><br><span class="line">  var value;</span><br><span class="line">  var active = false;</span><br><span class="line">  var accumulated = [];</span><br><span class="line"></span><br><span class="line">  return function accumulator() &#123;</span><br><span class="line">    accumulated.push(arguments);</span><br><span class="line">    if (!active) &#123;</span><br><span class="line">      active = true;</span><br><span class="line">      while (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(this, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = false;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sum = tco(function(x, y) &#123;</span><br><span class="line">  if (y &gt; 0) &#123;</span><br><span class="line">    return sum(x + 1, y - 1)</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    return x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(1, 100000)</span><br><span class="line">// 100001</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<p>函数参数的尾逗号<br>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function clownsEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果在param2或bar后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function clownsEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2,</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/23/2018-9-22-3-函数的扩展-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/2018-9-22-3-函数的扩展-1/" itemprop="url">2018-9-22-3 函数的扩展 1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-23T11:44:31+08:00">
                2018-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-9-22-3-函数的扩展-1"><a href="#2018-9-22-3-函数的扩展-1" class="headerlink" title="2018-9-22-3 函数的扩展 1"></a>2018-9-22-3 函数的扩展 1</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y) &#123;</span><br><span class="line">  y = y || &apos;World&apos;;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</span><br></pre></td></tr></table></figure></p>
<p>上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof y === &apos;undefined&apos;) &#123;</span><br><span class="line">  y = &apos;World&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</span><br></pre></td></tr></table></figure></p>
<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Point(x = 0, y = 0) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Point();</span><br><span class="line">p // &#123; x: 0, y: 0 &#125;</span><br></pre></td></tr></table></figure></p>
<p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>参数变量是默认声明的，所以不能用let或const再次声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(x = 5) &#123;</span><br><span class="line">  let x = 1; // error</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。</p>
<p>使用参数默认值时，函数不能有同名参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">function foo(x, x, y) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function foo(x, x, y = 1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// SyntaxError: Duplicate parameter name not allowed in this context</span><br></pre></td></tr></table></figure></p>
<p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 99;</span><br><span class="line">function foo(p = x + 1) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 100</span><br><span class="line"></span><br><span class="line">x = 100;</span><br><span class="line">foo() // 101</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p>
<h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1 2</span><br><span class="line">foo() // TypeError: Cannot read property &apos;x&apos; of undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // undefined 5</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。</p>
<p>下面是另一个解构赋值默认值的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fetch(url, &#123; body = &apos;&apos;, method = &apos;GET&apos;, headers = &#123;&#125; &#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(&apos;http://example.com&apos;, &#123;&#125;)</span><br><span class="line">// &quot;GET&quot;</span><br><span class="line"></span><br><span class="line">fetch(&apos;http://example.com&apos;)</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fetch(url, &#123; body = &apos;&apos;, method = &apos;GET&apos;, headers = &#123;&#125; &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(&apos;http://example.com&apos;)</span><br><span class="line">// &quot;GET&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。</p>
<p>作为练习，请问下面两种写法有什么差别？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure></p>
<h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h3><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;&#125;).length // 1</span><br><span class="line">(function (a = 5) &#123;&#125;).length // 0</span><br><span class="line">(function (a, b, c = 5) &#123;&#125;).length // 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(...args) &#123;&#125;).length // 0</span><br></pre></td></tr></table></figure></p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function (a = 0, b, c) &#123;&#125;).length // 0</span><br><span class="line">(function (a, b = 1, c) &#123;&#125;).length // 1</span><br></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = 1;</span><br><span class="line"></span><br><span class="line">function f(n, m = n) &#123;</span><br><span class="line">  console.log(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(2) // 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</p>
<p>再看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line"></span><br><span class="line">function f(y = x) &#123;</span><br><span class="line">  let x = 2;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</p>
<p>如果此时，全局变量x不存在，就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(y = x) &#123;</span><br><span class="line">  let x = 2;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></p>
<p>下面这样写，也会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line">function foo(x = x) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let foo = &apos;outer&apos;;</span><br><span class="line"></span><br><span class="line">function bar(func = () =&gt; foo) &#123;</span><br><span class="line">  let foo = &apos;inner&apos;;</span><br><span class="line">  console.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // outer</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。</p>
<p>如果写成下面这样，就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bar(func = () =&gt; foo) &#123;</span><br><span class="line">  let foo = &apos;inner&apos;;</span><br><span class="line">  console.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() // ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。</p>
<p>下面是一个更复杂的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">function foo(x, y = function() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  var x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 3</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</p>
<p>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">function foo(x, y = function() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 2</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure></p>
<p>最下面的代码进一步解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">function foo(x, y = function() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  x = 3;</span><br><span class="line">  console.log(x);</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() </span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure></p>
<p>去掉var之后，x = 3指向foo函数第一个变量了，y中的匿名函数的对x赋值也指向第一个函数了，所以y() 执行的x的结果会覆盖掉x = 3对参数赋值的结果。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throwIfMissing() &#123;</span><br><span class="line">  throw new Error(&apos;Missing parameter&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(mustBeProvided = throwIfMissing()) &#123;</span><br><span class="line">  return mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">// Error: Missing parameter</span><br></pre></td></tr></table></figure></p>
<p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p>
<p>应用<br>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throwIfMissing() &#123;</span><br><span class="line">  throw new Error(&apos;Missing parameter&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(mustBeProvided = throwIfMissing()) &#123;</span><br><span class="line">  return mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">// Error: Missing parameter</span><br></pre></td></tr></table></figure></p>
<p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(optional = undefined) &#123; ··· &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-rest-参数"><a href="#2-rest-参数" class="headerlink" title="2.rest 参数"></a>2.rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure></p>
<p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替arguments变量的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arguments变量的写法</span><br><span class="line">function sortNumbers() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// rest参数的写法</span><br><span class="line">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure></p>
<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  items.forEach(function(item) &#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    console.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [];</span><br><span class="line">push(a, 1, 2, 3)</span><br></pre></td></tr></table></figure></p>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f(a, ...b, c) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数的length属性，不包括 rest 参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(a) &#123;&#125;).length  // 1</span><br><span class="line">(function(...a) &#123;&#125;).length  // 0</span><br><span class="line">(function(a, ...b) &#123;&#125;).length  // 1</span><br></pre></td></tr></table></figure></p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(a, b) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function doSomething(a, b = a) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = function (&#123;a, b&#125;) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = (...a) =&gt; &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  // 报错</span><br><span class="line">  doSomething(&#123;a, b&#125;) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    // code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function doSomething(value = 070) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function doSomething(a, b = a) &#123;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种是把函数包在一个无参数的立即执行函数里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = (function () &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  return function(value = 42) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h2 id="4-name-属性"><a href="#4-name-属性" class="headerlink" title="4.name 属性"></a>4.name 属性</h2><p>函数的name属性，返回该函数的函数名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line">foo.name // &quot;foo&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">f.name // &quot;&quot;</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">f.name // &quot;f&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const bar = function baz() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">bar.name // &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">bar.name // &quot;baz&quot;</span><br></pre></td></tr></table></figure></p>
<p>Function构造函数返回的函数实例，name属性的值为anonymous。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Function).name // &quot;anonymous&quot;</span><br></pre></td></tr></table></figure></p>
<p>bind返回的函数，name属性值会加上bound前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name // &quot;bound foo&quot;</span><br><span class="line"></span><br><span class="line">(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/23/2018-9-22-1-数值的扩展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/2018-9-22-1-数值的扩展/" itemprop="url">2018-9-22-1 数值的扩展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-23T11:43:46+08:00">
                2018-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2018-9-22-1-数值的扩展"><a href="#2018-9-22-1-数值的扩展" class="headerlink" title="2018-9-22-1 数值的扩展"></a>2018-9-22-1 数值的扩展</h2><h3 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h3><p>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。</p>
<p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(15); // true</span><br><span class="line">Number.isFinite(0.8); // true</span><br><span class="line">Number.isFinite(NaN); // false</span><br><span class="line">Number.isFinite(Infinity); // false</span><br><span class="line">Number.isFinite(-Infinity); // false</span><br><span class="line">Number.isFinite(&apos;foo&apos;); // false</span><br><span class="line">Number.isFinite(&apos;15&apos;); // false</span><br><span class="line">Number.isFinite(true); // false</span><br></pre></td></tr></table></figure></p>
<p>注意，如果参数类型不是数值，Number.isFinite一律返回false。</p>
<p>Number.isNaN()用来检查一个值是否为NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(15) // false</span><br><span class="line">Number.isNaN(&apos;15&apos;) // false</span><br><span class="line">Number.isNaN(true) // false</span><br><span class="line">Number.isNaN(9/NaN) // true</span><br><span class="line">Number.isNaN(&apos;true&apos; / 0) // true</span><br><span class="line">Number.isNaN(&apos;true&apos; / &apos;true&apos;) // true</span><br></pre></td></tr></table></figure></p>
<p>如果参数类型不是NaN，Number.isNaN一律返回false。</p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">isFinite(25) // true</span><br><span class="line">isFinite(&quot;25&quot;) // true</span><br><span class="line">Number.isFinite(25) // true</span><br><span class="line">Number.isFinite(&quot;25&quot;) // false</span><br><span class="line"></span><br><span class="line">isNaN(NaN) // true</span><br><span class="line">isNaN(&quot;NaN&quot;) // true</span><br><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(&quot;NaN&quot;) // false</span><br><span class="line">Number.isNaN(1) // false</span><br></pre></td></tr></table></figure></p>
<h3 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h3><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">parseInt(&apos;12.34&apos;) // 12</span><br><span class="line">parseFloat(&apos;123.45#&apos;) // 123.45</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">Number.parseInt(&apos;12.34&apos;) // 12</span><br><span class="line">Number.parseFloat(&apos;123.45#&apos;) // 123.45</span><br></pre></td></tr></table></figure></p>
<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.parseInt === parseInt // true</span><br><span class="line">Number.parseFloat === parseFloat // true</span><br></pre></td></tr></table></figure></p>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p>Number.isInteger()用来判断一个数值是否为整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(25) // true</span><br><span class="line">Number.isInteger(25.1) // false</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(25) // true</span><br><span class="line">Number.isInteger(25.0) // true</span><br></pre></td></tr></table></figure></p>
<p>如果参数不是数值，Number.isInteger返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger() // false</span><br><span class="line">Number.isInteger(null) // false</span><br><span class="line">Number.isInteger(&apos;15&apos;) // false</span><br><span class="line">Number.isInteger(true) // false</span><br></pre></td></tr></table></figure></p>
<p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</p>
<p>Number.isInteger(3.0000000000000002) // true<br>上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。</p>
<p>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(5E-324) // false</span><br><span class="line">Number.isInteger(5E-325) // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。</p>
<p>总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。</p>
<h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON === Math.pow(2, -52)</span><br><span class="line">// true</span><br><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br><span class="line">Number.EPSILON.toFixed(20)</span><br><span class="line">// &quot;0.00000000000000022204&quot;</span><br></pre></td></tr></table></figure></p>
<p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2</span><br><span class="line">// 0.30000000000000004</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 - 0.3</span><br><span class="line">// 5.551115123125783e-17</span><br><span class="line"></span><br><span class="line">5.551115123125783e-17.toFixed(20)</span><br><span class="line">// &apos;0.00000000000000005551&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3 // false</span><br></pre></td></tr></table></figure></p>
<p>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>因此，Number.EPSILON的实质是一个可以接受的最小误差范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function withinErrorMargin (left, right) &#123;</span><br><span class="line">  return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 === 0.3 // false</span><br><span class="line">withinErrorMargin(0.1 + 0.2, 0.3) // true</span><br><span class="line"></span><br><span class="line">1.1 + 1.3 === 2.4 // false</span><br><span class="line">withinErrorMargin(1.1 + 1.3, 2.4) // true</span><br></pre></td></tr></table></figure></p>
<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>
<h3 id="安全整数和-Number-isSafeInteger"><a href="#安全整数和-Number-isSafeInteger" class="headerlink" title="安全整数和 Number.isSafeInteger()"></a>安全整数和 Number.isSafeInteger()</h3><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 53) // 9007199254740992</span><br><span class="line"></span><br><span class="line">9007199254740992  // 9007199254740992</span><br><span class="line">9007199254740993  // 9007199254740992</span><br><span class="line"></span><br><span class="line">Math.pow(2, 53) === Math.pow(2, 53) + 1</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>
<p>ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</span><br><span class="line">// true</span><br><span class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</span><br><span class="line">// true</span><br><span class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(&apos;a&apos;) // false</span><br><span class="line">Number.isSafeInteger(null) // false</span><br><span class="line">Number.isSafeInteger(NaN) // false</span><br><span class="line">Number.isSafeInteger(Infinity) // false</span><br><span class="line">Number.isSafeInteger(-Infinity) // false</span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(3) // true</span><br><span class="line">Number.isSafeInteger(1.2) // false</span><br><span class="line">Number.isSafeInteger(9007199254740990) // true</span><br><span class="line">Number.isSafeInteger(9007199254740992) // false</span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false</span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true</span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true</span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false</span><br></pre></td></tr></table></figure></p>
<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger = function (n) &#123;</span><br><span class="line">  return (typeof n === &apos;number&apos; &amp;&amp;</span><br><span class="line">    Math.round(n) === n &amp;&amp;</span><br><span class="line">    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= Number.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(9007199254740993)</span><br><span class="line">// false</span><br><span class="line">Number.isSafeInteger(990)</span><br><span class="line">// true</span><br><span class="line">Number.isSafeInteger(9007199254740993 - 990)</span><br><span class="line">// true</span><br><span class="line">9007199254740993 - 990</span><br><span class="line">// 返回结果 9007199254740002</span><br><span class="line">// 正确答案应该是 9007199254740003</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9007199254740993 === 9007199254740992</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function trusty (left, right, result) &#123;</span><br><span class="line">  if (</span><br><span class="line">    Number.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  throw new RangeError(&apos;Operation cannot be trusted!&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(9007199254740993, 990, 9007199254740993 - 990)</span><br><span class="line">// RangeError: Operation cannot be trusted!</span><br><span class="line"></span><br><span class="line">trusty(1, 2, 3)</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></p>
<h2 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h2><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(4.1) // 4</span><br><span class="line">Math.trunc(4.9) // 4</span><br><span class="line">Math.trunc(-4.1) // -4</span><br><span class="line">Math.trunc(-4.9) // -4</span><br><span class="line">Math.trunc(-0.1234) // -0</span><br></pre></td></tr></table></figure></p>
<p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(&apos;123.456&apos;) // 123</span><br><span class="line">Math.trunc(true) //1</span><br><span class="line">Math.trunc(false) // 0</span><br><span class="line">Math.trunc(null) // 0</span><br></pre></td></tr></table></figure></p>
<p>对于空值和无法截取整数的值，返回NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(NaN);      // NaN</span><br><span class="line">Math.trunc(&apos;foo&apos;);    // NaN</span><br><span class="line">Math.trunc();         // NaN</span><br><span class="line">Math.trunc(undefined) // NaN</span><br></pre></td></tr></table></figure></p>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc = Math.trunc || function(x) &#123;</span><br><span class="line">  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<p>参数为正数，返回+1；<br>参数为负数，返回-1；<br>参数为 0，返回0；<br>参数为-0，返回-0;<br>其他值，返回NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(-5) // -1</span><br><span class="line">Math.sign(5) // +1</span><br><span class="line">Math.sign(0) // +0</span><br><span class="line">Math.sign(-0) // -0</span><br><span class="line">Math.sign(NaN) // NaN</span><br></pre></td></tr></table></figure></p>
<p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(&apos;&apos;)  // 0</span><br><span class="line">Math.sign(true)  // +1</span><br><span class="line">Math.sign(false)  // 0</span><br><span class="line">Math.sign(null)  // 0</span><br><span class="line">Math.sign(&apos;9&apos;)  // +1</span><br><span class="line">Math.sign(&apos;foo&apos;)  // NaN</span><br><span class="line">Math.sign()  // NaN</span><br><span class="line">Math.sign(undefined)  // NaN</span><br></pre></td></tr></table></figure></p>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sign = Math.sign || function(x) &#123;</span><br><span class="line">  x = +x; // convert to a number</span><br><span class="line">  if (x === 0 || isNaN(x)) &#123;</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line">  return x &gt; 0 ? 1 : -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>ES2016 新增了一个指数运算符（**）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ** 2 // 4</span><br><span class="line">2 ** 3 // 8</span><br></pre></td></tr></table></figure></p>
<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 相当于 2 ** (3 ** 2)</span><br><span class="line">2 ** 3 ** 2</span><br><span class="line">// 512</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p>
<p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = 1.5;</span><br><span class="line">a **= 2;</span><br><span class="line">// 等同于 a = a * a;</span><br><span class="line"></span><br><span class="line">let b = 4;</span><br><span class="line">b **= 3;</span><br><span class="line">// 等同于 b = b * b * b;</span><br></pre></td></tr></table></figure></p>
<p>注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(99, 99)</span><br><span class="line">// 3.697296376497263e+197</span><br><span class="line"></span><br><span class="line">99 ** 99</span><br><span class="line">// 3.697296376497268e+197</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，两个运算结果的最后一位有效数字是有差异的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/23/2018-9-22-1-正则表达式的拓展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Dezheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/2018-9-22-1-正则表达式的拓展/" itemprop="url">2018-9-22-1 正则表达式的拓展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-23T11:42:53+08:00">
                2018-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2018-9-22-1-正则表达式的拓展"><a href="#2018-9-22-1-正则表达式的拓展" class="headerlink" title="2018-9-22-1 正则表达式的拓展"></a>2018-9-22-1 正则表达式的拓展</h2><p>y 修饰符<br>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</p>
<p>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa_aa_a&apos;;</span><br><span class="line">var r1 = /a+/g;</span><br><span class="line">var r2 = /a+/y;</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [&quot;aaa&quot;]</span><br><span class="line">r2.exec(s) // [&quot;aaa&quot;]</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [&quot;aa&quot;]</span><br><span class="line">r2.exec(s) // null</span><br></pre></td></tr></table></figure></p>
<p>上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa_aa_a&apos;;</span><br><span class="line">var r = /a+_/y;</span><br><span class="line"></span><br><span class="line">r.exec(s) // [&quot;aaa_&quot;]</span><br><span class="line">r.exec(s) // [&quot;aa_&quot;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<h3 id="11-具名组匹配"><a href="#11-具名组匹配" class="headerlink" title="11.具名组匹配"></a>11.具名组匹配</h3><p>简介<br>正则表达式使用圆括号进行组匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line"></span><br><span class="line">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class="line">const year = matchObj[1]; // 1999</span><br><span class="line">const month = matchObj[2]; // 12</span><br><span class="line">const day = matchObj[3]; // 31</span><br></pre></td></tr></table></figure></p>
<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<p>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;</span><br><span class="line"></span><br><span class="line">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class="line">const year = matchObj.groups.year; // 1999</span><br><span class="line">const month = matchObj.groups.month; // 12</span><br><span class="line">const day = matchObj.groups.day; // 31</span><br></pre></td></tr></table></figure>
<p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。</year></p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<p>如果具名组没有匹配，那么对应的groups对象属性会是undefined。</p>
<p>const RE_OPT_A = /^(?<as>a+)?$/;<br>const matchObj = RE_OPT_A.exec(‘’);</as></p>
<p>matchObj.groups.as // undefined<br>‘as’ in matchObj.groups // true<br>上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Liu Dezheng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Dezheng</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
